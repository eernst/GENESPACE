% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parse_annotations.R
\name{parse_annotations}
\alias{parse_annotations}
\alias{parse_phytozome}
\alias{parse_ncbi}
\alias{parse_gff}
\alias{parse_faHeader}
\title{Functions to convert from raw to genespace annotation formats}
\usage{
parse_phytozome(gsParam, overwrite = F, genomeIDs = NULL)

parse_ncbi(gsParam, overwrite = F, genomeIDs = NULL)

parse_annotations(
  genomeIDs = NULL,
  gsParam,
  gffEntryType = "gene",
  gffIdColumn = "Name",
  gffStripText = "",
  headerEntryIndex = 4,
  headerSep = " ",
  headerStripText = "locus=",
  overwrite = FALSE,
  troubleshoot = FALSE
)

parse_gff(
  path2rawGff3,
  gffEntryType,
  gffIdColumn,
  gffStripText,
  verbose = TRUE,
  troubleshoot = FALSE
)

parse_faHeader(
  path2rawFasta,
  headerEntryIndex,
  headerSep,
  headerStripText,
  verbose = TRUE,
  troubleshoot = FALSE
)
}
\arguments{
\item{gsParam}{a list containing all parameters for a GENESPACE run. See
init_genespace}

\item{overwrite}{logical, should existing files be overwritten? If FALSE,
and all files are present, just returns a named vector of gff/pep file
locations}

\item{genomeIDs}{character vector of the same length as paths. Names for
each genome.}

\item{gffEntryType}{character, specifying which attribute type should be
retained. This is the 3rd column of a gff3-formatted annotation. Can be a
vector of length 1, if all files should be parsed identically, or a vector
with the same length as file paths and genomeIDs, specifying different
parsing parameters for each genome.}

\item{gffIdColumn}{character, specifying the field name in the gff3
attributes column.Can be a vector of length 1, if all files should be parsed
identically, or a vector with the same length as file paths and genomeIDs,
specifying different parsing parameters for each genome.}

\item{gffStripText}{like headerStripText but for the gff geneID entry}

\item{headerEntryIndex}{integer specifying the field index in the fasta
header which contains the gene ID information to match with the gff. Can be a
vector of length 1, if all files should be parsed identically, or a vector
with the same length as file paths and genomeIDs, specifying different
parsing parameters for each genome.}

\item{headerSep}{character used as a field delimiter in the fasta header.
Can be a
vector of length 1, if all files should be parsed identically, or a vector
with the same length as file paths and genomeIDs, specifying different
parsing parameters for each genome.}

\item{headerStripText}{character or regex to remove from the fasta header.
Can be a vector of length 1, if all files should be parsed identically,
or a vector with the same length as file paths and genomeIDs, specifying
different parsing parameters for each genome.}

\item{troubleshoot}{logical, should the raw and parsed files be printed?}

\item{path2rawGff3}{character vector coercible to file.paths. This points to
the raw gff3-formatted annotation (.gz or gff3)}

\item{verbose}{logical, should updates be printed to the console?}

\item{path2rawFasta}{character string coercible to a file path, pointing to
the location of the unparsed fasta file.}
}
\description{
\code{parse_annotations} Format gff and fasta for genespace. The two parse
functions (parse_gff & parse_faHeader) take a single file and return a
formatted R object. format_annotations is a wrapper for these two that reads
and writes the full genespace-formatted files.

\code{parse_phytozome} parse phytozome-formatted annotations

\code{parse_ncbi} parse NCBI-formatted annotations

\code{parse_gff} parse the gff3-formatted annotation into genespace-readable
data.table/csv file. This has a unique ID for each gene that matches the
fasta annotation entries exactly.

\code{parse_faHeader} parse fasta headers to gene gff entries
}
\note{
\code{parse_annotations} is a generic name for the functions documented.
\cr
If called, \code{parse_annotations} returns its own arguments.
}
\examples{
\dontrun{
runwd <- file.path(getwd(), "testGenespace")
make_exampleDataDir(writeDir = runwd)

gpar <- init_genespace(
  genomeIDs = c("human","chimp","rhesus"),
  speciesIDs = c("human","chimp","rhesus"),
  versionIDs = c("human","chimp","rhesus"),
  outgroup = NULL,
  ploidy = rep(1,3),
  diamondMode = "fast",
  orthofinderMethod = "fast",
  wd = runwd,
  orthofinderInBlk = FALSE,
  overwrite = F,
  verbose = T,
  nCores = 4,
  minPepLen = 50,
  gffString = "gff",
  pepString = "pep",
  path2orthofinder = "orthofinder",
  path2diamond = "diamond",
  path2mcscanx = "~/Documents/comparative_genomics/programs/MCScanX",
  rawGenomeDir = file.path(runwd, "rawGenomes"))

# -- in the example dataset, the raw NCBI annotations have been parsed and
# subset to a more compact file format. Therefore, we cant use parse_ncbi
# and must use parse_annotations with some custom specs:
parse_annotations(
  gsParam = gpar,
  gffEntryType = "gene",
  gffIdColumn = "locus",
  gffStripText = "locus=",
  headerEntryIndex = 1,
  headerSep = " ",
  headerStripText = "locus=")
}
}
