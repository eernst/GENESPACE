% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/synteny.R, R/utils.R
\name{synteny}
\alias{synteny}
\alias{pipe_synteny}
\alias{set_syntenyParams}
\alias{run_mcscanx}
\alias{flag_synteny}
\alias{clus_dbscan}
\title{Parsing of pairwise hits into synteny}
\usage{
synteny(
  gsParam,
  genomeIDs = NULL,
  overwrite = FALSE,
  overwriteHits = overwrite,
  overwriteGff = overwrite,
  overwriteBlks = overwrite,
  minGenes4of = 40,
  recallSynteny = TRUE,
  ...
)

pipe_synteny(
  gsParam,
  gff,
  genomeIDs = unique(gff$genome),
  ogColumn = "globOG",
  nCores = NULL,
  verbose = TRUE,
  overwrite = FALSE
)

set_syntenyParams(
  gsParam,
  onlyOgAnchors = TRUE,
  onlyOgAnchorsSecond = FALSE,
  blkSize = 5,
  blkSizeSecond = blkSize,
  nGaps = 5,
  nGapsSecond = nGaps * 4,
  nSecondHits = 0,
  synBuff = 100,
  synBuffSecond = synBuff,
  selfRegionMask = synBuff * 5,
  arrayBuffer = sqrt(2 * (synBuff^2))
)

run_mcscanx(hits, blkSize, nGaps, gsParam, path2mcscanx)

flag_synteny(
  hits,
  gsParam,
  blkSize,
  synBuff,
  nhits1,
  nhits2,
  nGaps,
  selfOnly,
  maskTheseHits = NULL,
  onlyOgAnchors
)

clus_dbscan(hits, radius, blkSize)
}
\arguments{
\item{gsParam}{a list containing all parameters for a GENESPACE run. See
init_genespace}

\item{genomeIDs}{an optional vector of genomeIDs to consider. If not
specified (default) taken from gsParam$genomeIDs$genomeIDs}

\item{overwrite}{logical, should existing directories be overwritten?}

\item{overwriteHits}{logical, should existing hits be overwritten?}

\item{overwriteGff}{logical, should existing gff be overwritten?}

\item{overwriteBlks}{logical, should existing blocks be overwritten?}

\item{minGenes4of}{integer of length 1, specifying the minimum number of
unique genes on each sequence for orthofinder to be run}

\item{recallSynteny}{logical, should synteny be re-run after orthofinder
inblk. If so, the synteny parameter onlyOgAnchors and onlyOgAnchorsSecond
are both set to TRUE for the re-called iteration.}

\item{...}{additional arguments passed to set_syntenyParam().}

\item{gff}{data.table containing the gff-like annotatin information}

\item{ogColumn}{character length 1, specifying the column in the gff
data.table to use as the orthogroup vector}

\item{nCores}{integer of length 1, specifying the number of parallel
processes to run}

\item{verbose}{logical, should updates be printed to the console}

\item{onlyOgAnchors}{logical, should only hits in orthogroups be considered
for anchors?}

\item{onlyOgAnchorsSecond}{logical should only hits in orthogroups be
considered for anchors in secondary blocks?}

\item{blkSize}{integer of length 1, specifying the -s param to mcscanx}

\item{blkSizeSecond}{see blkSize, but passed to the secondary scan if
nSecondaryHits > 0.}

\item{nGaps}{integer of length 1, specifying the -m param to mcscanx
for the primary MCScanX run. This acts on the results from the initial
MCScanX run.}

\item{nGapsSecond}{see nGaps, but passed to secondary hits after masking
primary hits.}

\item{nSecondHits}{integer of length 1, specifying the number of blast
hits to include after masking.}

\item{synBuff}{Numeric > 0, specifying the distance from an anchor
to consider a hit syntenic. This parameter is also used to limit the search
radius in dbscan-based blk calculation. Larger values will return larger
tandem arrays but also may permit inclusion of spurious non-syntenic networks}

\item{synBuffSecond}{see syntenyBuffer. Applied only to synteny
construction of secondary hits.}

\item{selfRegionMask}{integer specifying the size of the region (radius, gene
rank order) surrounding self hits to mask for secondary/homeologous hits}

\item{arrayBuffer}{Numeric length 1, specifying the maximum gene-rank order
position of two genes to be considered members of the same collinear array.
Set to synBuff + 1 if smaller than the maximum synBuff or sqrt(2*(synBuff^2))
if not specified.}

\item{hits}{data.table of hits}

\item{path2mcscanx}{character string file.path pointing to the install
directory for the MCScanX program. In particular, there must be an
executable in this directory for MCScanX_h.}

\item{nhits1}{integer of length 1, specifying the top n hits to retain for
each gene on genome 1}

\item{nhits2}{integer of length 1, specifying the top n hits to retain for
each gene on genome 2}

\item{selfOnly}{logical, should only self hits be used? This is much faster.}

\item{maskTheseHits}{character vector paste of the pairwise blast orthofinder
gene IDs. Used to mask hits in the hits object}

\item{radius}{numeric of length 1 specifying the search radius.}

\item{maxIter}{integer of length 1 specifying the maximum number of
iterations}

\item{blks}{data.table containing the block coordinates. See calc_blkCoords}
}
\value{
Synteny functions produce three types of outputs: (1) a 'hits'
data.table, (2) a 'blocks' data.table, and (3) the genespace parameter list
'gsParam' in tutorials. Here, are is the metadata for the first two outputs.

Hits output stored as results/$genome1_$genome2_synHits.txt.gz. Columns names
ending in '1' are the target gene and '2' are the query.
\enumerate{
\item ofID1/2: orthofinder unique ID for each gene.
\item score: the diamond blast-like bit score
\item gen1/2: genome IDs, as specified in init_genespace
\item start1/2: gff-derived gene start position in basepairs
\item end1/2: gff-derived gene end position in basepairs
\item chr1/2: gff-derived chromosome IDs
\item ord1/2: gene-rank order across the genome
\item scrRank1/2: within-gene score rank, higher score = lower rank
\item arrayID1/2: collinear array ID, defined as genes in the same orthogroup
within the synteny buffer within a chromosome.
\item arrayOrd1/2: the condensed order of genes, by arrayID
\item isRep1/2: is gene1/2 a representative of its array, defined as the most
centrally located gene within the array and the longest peptide (tiebreaker)
\item isOg: are both query and target in the same orthogroup?
\item nChr1/2: number of unique genes on chr1/2.
\item blkID: syntenic block ID
\item regID: large syntenic region ID (regions may be interleafed)
\item isAnchor: is this hit a syntenic block anchor?
\item inBuffer: is this hit within the synBuffer of an anchor?
}

\cr
If called, \code{synteny} returns its own arguments.
}
\description{
\code{synteny} The main GENESPACE engine to constrain genome-wide homology
hits to synteny.

\code{pipe_synteny} pipe_synteny

\code{set_syntenyParams} Calculate paramters for pairwise synteny search.
Other synteny functions require this as input.

\code{run_mcscanx} Internal GENESPACE function to run MCScanX on hits when
searching for synteny.

\code{flag_synteny} flag_synteny

\code{clus_dbscan} clus_dbscan
}
\details{
The main engine for GENESPACE synteny searching. This
finds syntenic 'anchors' that are high-confidence synteny- and homology-
constrained hits, then pulls nearby hits within a specified buffer around
'anchor' hits between two genomes. Combined, this provides a framework to
both analyze syntenic duplicates (e.g. tandem arrays) and have high
confidence that only the desired types of hits (orthologs, homoeologs, etc.)
are considered.

Synteny produces two measures of collinearity between pairs of genomes:
the collinear block, flagged as "blkID" and the large syntenic region,
flagged as "regID". The syntenic anchors for each of these types of synteny
are flagged in the logical "isAnchor" column (TRUE). Hits within the syntenic
buffer that are not anchors are flagged with the appropriate regID and blkID.
Both anchors and those in the syntenic buffer are flagges in the logical
column "inBuffer" (TRUE).
both blkIDs and regIDs and

Parameterization of synteny is complex and varies by the type of
contrast desired. To simplify parameterization, we have build a convenience
function that infers various parameters based on basic
genespace parameters and ploidy. Set set_syntenyParams for more information
about the input synParam data.table.
}
\examples{
\dontrun{

runwd <- file.path(getwd(), "testGenespace")
make_exampleDataDir(writeDir = runwd)

gpar <- init_genespace(
  genomeIDs = c("human","chimp","rhesus"),
  speciesIDs = c("human","chimp","rhesus"),
  versionIDs = c("human","chimp","rhesus"),
  ploidy = rep(1,3),
  diamondMode = "fast",
  orthofinderMethod = "fast",
  wd = runwd,
  nCores = 4,
  minPepLen = 50,
  gffString = "gff",
  pepString = "pep",
  path2orthofinder = "orthofinder",
  path2mcscanx = "~/MCScanX",
  rawGenomeDir = file.path(runwd, "rawGenomes"))

parse_annotations(
  gsParam = gpar,
  gffEntryType = "gene",
  gffIdColumn = "locus",
  gffStripText = "locus=",
  headerEntryIndex = 1,
  headerSep = " ",
  headerStripText = "locus=")

gpar <- run_orthofinder(gsParam = gpar, overwrite = F)

gpar <- synteny(gsParam = gpar) # use defaults

# -- run again (need to set overwrite = T) with blkSize = 10
gpar$params$synteny <- NULL
gpar <- synteny(gsParam = gpar, blkSize = 10, overwrite = T)

# -- run again with custom specs
# **NOTE** if params$synteny is a data.table, synteny will respect it. So,
# this can be generated and modified before running. If it is NULL (as above)
#synteny will calculate parameters internally with additional arguments.

# here, increase the synteny buffer and
# make the blocks need to be bigger between human and chimp
gpar <- set_syntenyParams(gpar, synBuff = 200)
wh <- with(gpar$params$synteny, which(
  genome1 \%in\% c("humnan", "chimp") & genome2 \%in\% c("humnan", "chimp")))
gpar$params$synteny$blkSize[wh] <- 10
gpar <- synteny(gsParam = gpar, overwrite = T)
}


}
